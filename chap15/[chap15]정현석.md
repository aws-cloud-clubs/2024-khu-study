# #15 구글 드라이브 설계

## Step1. 문제 이해 및 설계 범위 확정

- 파일 추가
- 파일 다운로드
- 여러 단말에 파일 동기화
- 파일 갱신 이력 조회(revision history)
- 파일 공유
- 파일이 편집되거나 삭제되거나 새롭게 공유되었을 때 알림 표시

### 개략적 추정치

- 가입 사용자는 오천만(50million) 명이고 천만 명의 DAU 사용자가 있다고 가정
- 모든 사용자에게 10GB의 무료 저장공간 할당
- 매일 각 사용자가 평균 2개의 파일을 업로드 한다고 가정
    - 각 파일의 평균 크기는 500KB
- 읽기:쓰기 비율은 1:1
- 필요한 저장 공간 총량 = 5천만 사용자 * 10GB = 500페타바이트(Petabyte)
- 업로드 API QPS = 1천만 사용자 * 2회 업로드/24시간/3600초 = 약 240
- 최대 QPS = QPS * 2 = 480


## Step2. 개략적 설계안 제시 및 동의 구하기

### API

이 시스템은 기본적으로 세 가지 API가 필요하다. 파일 업로드 API, 다운로드 API 그리고 파일 갱신 히스토리 제공 API다.

1. **파일 업로드 API**

이 시스템은 두 가지 종류의 업로드를 지원한다.

- 단순 업로드
- 이어 올리기(resumable upload)

![이어 올리기 API의 예](https://github.com/user-attachments/assets/1131f0c1-fae1-4b66-8f1b-68cebc9b0e69)

**인자**

- uploadType = resumable
- data
    - 업로드할 로컬 파일

이어 올리기는 다음 세 단계 절차로 이루어진다.

- 이어 올리기 URL을 받기 위한 최초 요청 전송
- 데이터를 업로드하고 업로드 상태 모니터링
- 업로드에 장애가 발생하면 장애 발생시점부터 업로드를 재시작


2. **파일 다운로드 API**

![파일 다운 API의 예](https://github.com/user-attachments/assets/77bea155-82b6-4aa4-b3dc-15200990fb20)

**인자**

- path
    - 다운로드할 파일의 경로


3. **파일 갱신 히스토리 API**

![파일 갱신 히스토리 API의 예](https://github.com/user-attachments/assets/bbf55c76-1006-41f0-8a06-c8e11113b3ec)


**인자**

- path
    - 갱신 히스토리를 가져올 파일의 경로
- limit
    - 히스토리 길이의 최대치

지금까지 나열한 모든 API는 사용자 인증을 필요로 하고 HTTPS 프로토콜을 사용해야 한다. SSL(Secure Socket Layer)를 지원하는 프로토콜을 이용하는 이유는 클라이언트와 백엔드 서버가 주고받는 데이터를 보호하기 위한 것이다.

### 한 대 서버의 제약 극복
가장 먼저 떠오르는 해결책은 데이터를 샤딩하여 여러 서버에 나누어 저장하는 것이다.

### 동기화 충돌
이런 충돌은 다음과 같은 전략으로 해소할 수 있다. 먼저 처리되는 변경은 성공한 것으로 보고, 나중에 처리되는 변경은 충돌이 발생한 것으로 표시하는 것이다.

![동기화 충돌 사례](https://github.com/user-attachments/assets/8ed501c5-47b7-4ec1-ac66-901ab93f07d6)

### 개략적 설계안

![개략적 설계안](https://github.com/user-attachments/assets/a317e6d8-bd37-4c7e-81b4-08d493cbac87)

각각의 컴포넌트에 대해 조금 더 상세히 알아보자.

- 사용자 단말
    - 사용자가 이용하는 웹브라우저나 모바일 앱 등의 클라이언트
- 블록 저장소 서버(block server)
    - 파일 블록을 클라우드 저장소에 업로드하는 서버
    - 블록 수준 저장소(block-level storage)라고도 부르며, 클라우드 환경에서 데이터 파일을 저장하는 기술
    - 파일을 여러 개의 블록으로 나눠 저장하며, 각 블록에는 고유한 해시 값이 할당됨
        - 이 해시값은 메타데이터 데이터베이스에 저장
    - 각 블록은 독립적인 객체로 취급되며 클라우드 저장소 시스템(본 설계안의 경우 S3)에 보관
    - 파일을 재구성하려면 블록들을 원래 순서대로 합쳐야 함
    - 예시한 설계안의 경우 한 블록은 드롭박스의 사례를 참고하여 최대 4MB로 측정
- 클라우드 저장소
    - 파일은 블록 단위로 나눠져 클라우드 저장소에 보관
- 아카이빙 저장소(cold storage)
    - 오랫동안 사용되지 않은 비활성(inactive) 데이터를 저장하기 위한 컴퓨터 시스템
- 로드밸런서
    - 요청을 모든 API 서버에 고르게 분산하는 역할
- API 서버
    - 파일 업로드 외에 거의 모든 것을 담당하는 서버
    - 사용자 인증, 사용자 프로파일 관리, 파일 메타데이터 갱신 등에 사용
- 메타데이터 데이터베이스
    - 사용자, 파일, 블록, 버전 등의 메타데이터 정보를 관리
    - 실제 파일은 클라우드에 보관
    - 이 데이터베이스는 오직 메타데이터만 둔다는 것을 명심
- 메타데이터 캐시
    - 성능을 높이기 위해 자주 쓰이는 메타데이터는 캐시
- 알림 서비스
    - 특정 이벤트가 발생했음을 클라이언트에게 알리는데 쓰이는 발생/구독 프로토콜 기반 시스템
    - 예시 설계안의 경우에는 클라이언트에게 파일이 추가되었거나, 편집되었거나, 삭제되었음을 알려 파일의 최신 상태를 확인하는데 쓰임
- 오프라인 사용자 백업 큐(offline backup queue)
    - 클라이언트가 접속 중이 아니라서 파일의 최신 상태를 확인할 수 없을 때는 해당 정보를 이 큐에 두어 나중에 클라이언트가 접속했을 때 동기화 하도록 사용


## Step3. 상세 설계

### 블록 저장소 서버

정기적으로 갱신되는 큰  파일들은 업데이트가 일어날 때마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 잡아 먹는다.  
이를 최적화하는 방법으로는 다음의 두 가지 정도를 생각할 수 있다.

- 델타 동기화(delta sync)

- 압축(compression)

### 높은 일관성 요구사항

이 시스템은 강한 일관성 모델을 기본으로 지원해야 한다. 같은 파일이 단말이나 사용자에 따라 다르게 보이는 것은 허용할 수 없다는 뜻이다. 메타데이터 캐시와 데이터베이스 계층에도 같은 원칙이 적용되어야 한다.  
메모리 캐시는 보통 결과적 일관성(eventual consistency) 모델을 지원한다. 따라서 강한 일관성을 달성하려면 다음 사항을 보장해야 한다.

- 캐시에 보관된 사본과 데이터베이스에 있는 원본(master)이 일치
- 데이터베이스에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화

### 업로드 절차
크게 다음과 같은 두 가지 경우로 나눠진다.
- 파일 메타 데이터 추가
    1. Sender가 새 파일의 메타데이터를 추가하기 위한 요청 전송
    2. 새 파일의 메타데이터를 데이터베이스에 저장하고 업로드 상태를 대기중(pending)으로 변경
    3. 새 파일이 추가되었음을 알림 서비스에 통지
    4. 알림 서비스는 관련된 유저에게 파일이 업로드 되었다고 알림

- 파일을 클라우드 저장소에 업로드
    1. Sender가 파일을 블록 저장소 서버에 업로드
    2. 블록 저장소 서버는 파일을 블록 단위로 쪼갠 다음 압축하고 암호환 한 다음에 클라우드 저장소에 전송
    3. 업로드가 끝나면 클라우드 스토리지는 완료 콜백을 호출, 이 콜백 호출은 API 서버로 전송됨
    4. 메타데이터 DB에 기록된 해당 파일의 상태를 완료(uploaded)로 변경
    5. 알림 서비스에 파일 업로드가 끝났음을 통지
    6. 알림 서비스는 관련된 유저에게 파일 업로드가 끝났음을 알림

### 다운로드 절차
파일 다운로드는 파일이 새로 추가되거나 편집되면 자동으로 시작된다.  
클라이언트는 다른 클라이언트가 파일을 편집하거나 추가했다는 사실을 다음과 같은 두 가지 방법을 사용하여 감지할 수 있다.

- 클라이언트 A가 접속 중이고 다른 클라이언트가 파일을 변경하면 알림 서비스가 클라이언트 A에게 변경이 발생했으니 새 버전을 끌어가야 한다고 알림
- 클라이언트 A가 네트워크에 연결된 상태가 아닐 경우에는 데이터는 캐시에 보관될 것이며, 해당 클라이언트의 상태가 접속 중으로 바뀌면 그때 해당 클라이언트는 새 버전을 가져감

어떤 파일이 변경되었음을 감지한 클라이언트는 우선 API 서버를 통해 메타데이터를 새로 가져가야 하고, 그 다음에 블록들을 다운받아 파일을 재구성해야 한다.

### 알림 서비스
파일의 일관성을 유지하기 위해, 클라이언트는 로컬에서 파일이 수정되었음을 감지하는 순간 다른 클라이언트에 그 사실을 알려서 충돌 가능성을 줄여야 한다.  
알림 서비스의 이용 목적을 단순하게 보자면 알림 서비스는 이벤트 데이터를 클라이언트들로 보내는 서비스다. 따라서 다음 두 가지 정도의 선택지가 있다.

- 롱 폴링(long polling)
- 웹소켓(WebSocket)

### 저장소 공간 절약

- 중복 제거(de-dupe)
- 지능적 백업 전략을 도입하며 다음과 같은 전략을 생각할 수 있음
- 자주 쓰이지 않는 데이터는 아키이빙 저장소(cold storage)를 사용

### 장애 처리

- 로드밸런서 장애
- 블록 저장소 서버 장애
- 클라우드 저장소 장애
- API 서버 장애
- 메타데이터 캐시 장애
- 메타데이터 데이터베이스 장애
- 알림 서비스 장애
- 오프라인 사용자 백업 큐 장애