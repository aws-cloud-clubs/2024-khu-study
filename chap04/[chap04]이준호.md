# #4 처리율 제한 장치의 설계

클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기
위함.

- 사용자는 초당 2회 이상 새 글을 올릴 수 없다.
- 같은 IP로 하루에 10개 이상의 계정을 생성할 수 없다.
- 등등

\*요청을 제한하는 이유?

1. Dos 공격에 의한 자원고갈을 방지
2. 비용절감(서버를 많이 두지 않아도 됨. 제3자 API를 이용한다면 더욱 요금 절감)
3. 서버 과부하 방지.

## 1단계 문제 이해 및 설계 범위 확정

- 어떤 종류의 처리율 제한 장치인가? : 서버 or 클라이언트
- API호출 제어 기준? : IP, ID, ETC
- 시스템 규모? : 스타트업, 대기업 ,,,
- 분산환경에서 동작?
- 독립적인지 애플리케이션에 포함인지

요약

- 설정된 처리율을 초과하는 요청은 확실히 제한
- 낮은 응답시간: 응답시간에 나쁜 영향을 주지 않을 것.
- 가능한 적은 메모리 사용
- 분산형 처리율 제한: 하나의 처리율 제한 장치를 여러 서버나 프로레서에서 공유
- 높은 결함 감내성: 제한 장치에 장애가 생기더라도 전제 시스템 영향 X

## 2단계 개력적 설계안 제시 및 동의 구하기

> 장치를 두는 위치

- 클라이언트: 위변조가 가능하므로 통제하기 어려움
- 서버
- 처리율 제한을 위한 미들웨어

2,3번 중 정답은 X.
회사의 기술 스택, 엔지니어링 인력, 우선순위, 목표에 따라 다름.

고려 예시

- 프로그래밍 언어, 캐시 서비스 등의 기술 스택이 서버측 구현을 지원하기 충분할 정도로 효율이 좋은가?
- 사업에 맞는 처리율 제한 알고리즘은 무엇인가? (제 3자 API라면 제한될 수 있음)
- 직접만드는게 나은가? 기존 서비스를 이용하는게 나은가?
- 게이트웨이에 포함해야 하나?(마이크로서비스기반, API게이트웨이가 설계에 포함되었나?)

### 처리율 제한 알고리즘

**1. 토큰 버킷 알고리즘**
정해진 토큰버킷(O O O)이 있고 토큰은 주기적으로 추가된다.
한 요청당 토큰버킷에서 토큰을 하나 소모한다(O O)
토큰을 할당받지 못한( ) 요청은 버린다.

장점

- 구현이 쉬움
- 메모리 사용이 효율적
- 짧은 시간에 집중되는 트래픽도 처리 가능

단점

- 버킷 크기와 토큰 공급률(주기, 공급량)을 적절히 튜닝하기 까다로움.

**2. 누출 버킷 알고리즘**
FIFO큐로 구현. 큐에 빈자리가 있다면 요청 추가. 가득 차 있다면 버림.

장점

- 큐 크기가 제한되어 있어 메모리 효율적
- 고정된 처리율 -> 안정적인 출력

단점

- 단시간에 몰리는 트래픽 -> 오래된 요청이 쌓여 최신 요청이 버려짐
- 마찬가지로 버킷크기와 처리율 튜닝이 까다로움.

**3.고정 윈도 카운터 알고리즘**

- 타임라인을 고정된 간격의 윈도로 나누고 윈도마다 카운터를 붙인다.
- 카운터 값이 임계치에 도달하면 새로운 요청은 버린다.

장점

- 메모리 효율적
- 이애하기 쉬움
- 윈도가 닫히는 시점에 카운터 초기화 - 특정 트래픽 패턴을 처리하기 적합

단점

- 윈도 경계 부근에 일시적으로 ㅁ낳은 트래픽 -> 처리 한도보다 많은 양의 요청을 처리

**4. 이동 윈도 로깅 알고리즘**
고정 윈도 카운터 알고리즘의 문제(경계부근에 트래픽이 몰리는 경우 한도보다 많은 요청 처리)를 해결.

요청의 타임스탬프를 추적. 만료된 타임스탬프를 고려하여 처리

장점

- 허용되는 요청은 처리율 한도를 넘지 않음

단점

- 다량의 메모리 사용(거부되는 요청의 타임스탬프 저장)

**5. 이동 윈도 카운터 알고리즘**

고정 윈도 카운터와 윈도 로깅 알고리즘을 결합.

장점

- 이전 시간대 평균 처리율에 따라 윈도 상태 계산 - 몰리는 트래픽에도 잘 대응
- 메모리 효율

단점

- 직전 시간대 도착한 요청이 균등하다 가정하고 추정치를 계산하므로 다소 느슨. (생각만큼 심각하지는 않음)

### 개략적인 아키텍처

처리율 제한 알고리즘의 기본 아이디어 : 얼마나 많은 요청이 접수 되었는지 카운터를 추적 대상별로 두고 카운터 값이 임계값을 넘으면 거부하자.

카운터 보관은? DB는 디스크 접근하므로 느림. 따라서 캐시.
Redis는 처리율 제한 장치를 구현할 때 자주 사용되는 메모리 기반 저장장치.
INCR : 메모리에 저장된 카운터 값 1증가
EXPIRE: 카운터에 타임아웃 값 설정.

## 3단계 상세설계

> 처리율 한도 초과 트래픽 처리

한도 제한에 걸리면 HTTP 429 응답을 클라이언트에 보냄.
나중에 처리하기 위해 큐에 보관할 수도 있음.

그때 헤더는..

- X-Ratelimit-Remaining: 윈도 내에 남은 처리 가능 요청의 수.
- X-Ratelimit-Limit: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수.
- X-Ratelimit-Retry-After: 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지 알림.

![image](https://velog.velcdn.com/images/clock509/post/a17c4b75-b487-4de2-aed6-3fb00015b5d2/image.jpg)

> 분산 환경에서의 처리율 제한 장치의 구현

race condition과 synchronization문제를 해결해야함.

**race conditon 해결책**

- 락을 사용 -> 시스템 선응을 떨어뜨림.
- 루아 스크립트
- 저정렬 집함(레디스 자료구조)

**동기화**
클라이언트 요청은 그때그때 다른 처리율 제한 장치 서버로 보내질 수 있고 이때 처리율 제한 장치 서버들이 같은 상태를 공유하지 않는다면 올바른 수행을 할 수 없음.

**해결책**

- 레디스 같은 중앙 집중형 데이터 저장소를 사용한다.

> 성능 최적화

- 세계 곳곳에 에지 서버를 두어 지연시간을 줄인다.
- 제한 장치간 데이터를 동기화 할때 최종 일관성 모델을 사용한다.

> 모니터링

- 채택된 처리율 제한 알고리즘이 효과적인가
- 정의한 처리율 제한 규칙이 효과적인가

## 4단계 마무리

- hard(임계치를 절대 넘어가지 않음) or soft(임계치를 잠시 넘어설 수 있음) 처리율 제한
- 다양한 계층에서의 처리율 제한
- 처리율 제한을 회피하는 방법 (API호출 줄이기, 예외나 에러처리 코드를 통한 우아한 복구)
