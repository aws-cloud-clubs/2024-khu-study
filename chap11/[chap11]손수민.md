# Chap 11. 뉴스 피드 시스템 설계

### 1단계: 문제 이해 및 설계 범위 확정

- 사용자는 뉴스 피드 페이지에 새로운 스토리 업로드와 친구의 스토리를 볼 수 있다.
- 시간 흐름 역순(reverse chronological order)으로 표시
- 한 명의 사용자는 최대 5,000명을 가질 수 있음 

### 2단계: 개략적 설계안 제시 및 동의 구하기

**feed publishing**

- 피드 발생 API
- 피드 읽기 API

![image](https://github.com/user-attachments/assets/8b9daaf3-4f3b-4303-9693-a2e8541fa475)

**news feed building**

![image](https://github.com/user-attachments/assets/8e03c702-3ff9-49c4-a8e7-c04f7644d04e)

### 3단계: 상세 설계

**웹 서버**

- 클라이언트 통신
- 인증이나 처리율 제한 등의 기능 수행
- 인증 토큰으로 보안 강화
- 특정 기간 동나 한 사용자가 올릴 수 있는 포스팅의 수 제한

**포스팅 전송(팬아웃) 서비스**

- 쓰기 시점에 팬아웃(fanout-on-write)하는 모델: 새로운 포스팅을 기록하는 시점에 뉴스 피드 갱신
    - 장점) 뉴스 피드가 실시간으로 갱신되며 친구 목록에 있는 사용자에게 즉시 전송. 새 포스팅이 기록되는 순간 뉴스 피드가 이미 갱신되므로 뉴스 피드를 읽는 데 드는 시간이 짧아진다.
    - 단점) 핫키 문제. 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신하여 컴퓨팅 자원 낭비
- 읽기 시점에 팬아웃(fanout-on-read)하는 모델: 요청 기반(on-demand) 모델로 사용자가 로딩하는 시점에 새로운 포스트를 가져오게 된다.
    - 장점) 비활성화된 사용자 또는 거의 로그인하지 않는 사용자의 경우 컴퓨팅 자원 낭비가 없다. 핫키 문제 X
    - 단점) 뉴스 피드를 읽는 데 많은 시간이 소요될 수 있따.

-> 기본적으로 쓰기 시점에 팬아웃하는 모델을 사용하고, 친구가 많은 사용자는 읽기 시점에 팬아웃을 사용하여 시스템 과부하 방지할 것이다. 안정 해시를 통해 요청과 데이터를 고르게 분산하여 핫키 문제 줄일 것이다.

**캐시 구조**

- 뉴스피드: 뉴스 피드 ID 보관
- 콘텐츠: 포스팅 데이터 보관. 인기 콘텐츠는 따로 보관.
- 소셜 그래프: 사용자 간 관계 정보 보관
- 행동(action): 좋아요, 답글, ...
- 횟수(counter): 좋아요 횟수, 답글 횟수, 팔로어 수, 팔로잉 수, ...

### 4단계: 마무리

데이터베이스 규모 확장
- 수직적 규모 확장 vs 수평적 규모 확장
- SQL vs NoSQL
- Master-slave 다중화
- Replica에 대한 읽기 연산
- Consistency model
- Database Sharding

이 외의 논의 사항
- Stateless 설계
- 가능한 많은 데이터 캐시할 방법
- 여러 데이터 센터 지우너할 방법
- 메시지 큐를 사용하여 컴포넌트 사이의 결합도 낮추기
- 핵심 메트릭(key metric)에 대한 모니터링
