# #1 사용자 수에 따른 규모 확장성

## 단일 서버

모든 컴포넌트가 단 한대의 서버에서 실행되는 간단한 시스템.

> 구성

- 웹 앱, DB, 캐시 등,,
  > 흐름

1. DNS를 통한 사이트 접속
2. DNS를 통해 얻은 IP로 HTTP요청 전달
3. 응답 반환(HTML or JSON)

## 데이터베이스

사용자가 늘면 서버 하나로는 불충분. → 여러 서버가 필요하다
보통 하나는 웹/모바일 트래픽 처리, 하나는 DB용
웹 계층과 데이터 계층을 나누면 독립적으로 확장할 수 있게 됨.

> 어떤 DB를 사용할까?

**관계형 DB / RDB**

- 테이블, 열, 칼럼으로 표현
- SQL을 통해 JOIN 가능

**비관계형 DB / NoSQL(Not Only SQL)**
분류

- 키-값 저장소
- 그래프 저장소
- 칼럼 저장소
- 문서 저장소

사용하는 경우

- 낮은 지연시간 요구
- 비정형 데이터 처리
- 데이터를 직렬화/역직렬화 할 수 있기만 하면 됨 (데이터를 저장/통신에 사용하기 위함)
- 아주 많은 양의 데이터를 저장 해야 함

## 수직적 규모 확장 vs 수평적 규모 확장

- Scale up : 수직적 규모 확장
  H/W 업그레이드
- Scale out : 수평적 규모 확장
  동일 스펙, 개수를 늘림

> 수직적 규모의 한계

- 확장에 한계가 있다. 무한대로 CPU, RAM을 늘릴 수 없음
- 서버 장애 발생시 완전히 중단.
  따라서 대규모 애플리케이션이라면 수평적 규모 확장법이 적절함.

> 로드 밸런서

트래픽 부하를 고르게 분산하는 역할.
로드밸런서의 public ip로 접속, 웹 서버는 private ip가 되어 접속을 직접 처리하지 않음.
→ 장애 자동 복구(A가 다운이면 B로 보내기) , 웹 계층 가용성(필요하면 서버를 추가) 향상

> DB 다중화

서버간 master 와 slave 관계 설정. master에는 원본, 사본은 slave에 저장.
→ 쓰기는 master만 지원
→ salve는 읽기만 가능.
→ 대부분의 애플리케이션의 연산은 read! (#Master < #Slave)

> DB다중화의 이점

- 분산/병렬 처리 되므로 더 나은 성능
- 일부가 고장나도 데이터가 유지되는 안정성
- 여러 지역에 데이터를 복사하여 장애 발생시에도 서비스는 계속되는 가용성

## 캐시

응답 시간 개선을 위해 캐시를 붙이고, 정적 콘텐츠를 CDN으로 옮기면 개선할 수 있다.
자주 참조되는 데이터를 메모리에 두어 빨리 처리하자.

- [웹 서버] - [캐시] - [DB] 와 같이 캐시서버를 구성할 수 있다.
- 응답 시간 개선 외에도 DB부하를 줄이거나 캐시 계층의 규모를 독립적으로 확장시킬 수 있다.
- 캐시할 데이터의 종류, 크기, 액세스 패턴에 따라 다양한 전략이 존재.

> 유의할 점

- 갱신은 자주 일어나지 않고 참조는 빈번한 경우 고려할만 함.
- 캐시는 휘발성이므로 중요한 데이터는 지속적 저장소에 둘 것.
- 캐시의 데이터를 너무 오래 보관하면 원본과 차이가 날 가능성↑ 짧으면 너무 자주 DB에 접근
- 원본과 캐시 데이터가 같은지,,한 트랜잭션에서 처리되지 않는다면 일관성 유지하는게 어려운 문제.
- 장애를 피하려면 캐시 서버도 분산시킬 것.
- 캐시 메모리 크기가 너무 작으면 데이터가 너무 자주 밀려남(evuctuin). 과할당을 통해 해결
- 데이터 eviction정책은?
  - LRU 접근이 오래된 것
  - LFU 사용 빈도가 적은 것
  - FIFO 들어온대로

## 콘텐츠 전송 네트워크 (CDN)

정적 콘텐츠를 전송하는데 사용하는 지리적으로 분산된 서버의 네트워크.
IMG, VIDEO, CSS ,JS 파일 등을 캐싱

> 고려 사항

- 비용 : CDN은 보통 제 3자가 운영. 자주 사용하지 않는 콘텐츠를 캐싱하는 것은 비효율
- 적절한 만료 시한 설정 : 너무 길면 신선도가 떨어지고 짧으면 원본 서버에 자주 접속해야 함
- CDN 장애 대처 : CDN이 죽었다면 원본 서버에서 가져오도록 클라이언트를 구성해야 할 수도 있음.
- 콘텐츠 무효화 방법 : 만료 되지 않았다 하더라도 CDN사업자가 제공하는 API, 오브젝트 버저닝을 통해 CDN에서 제거할 수 있음.

## Stateless 웹 계층

웹 계층의 수평적 확장을 위해 사용자 세션같은 상태정보를 웹 계층에서 제거해야 함.

- 상태 정보는 DB에 저장하고 필요할 때 가져옴. ==> 무상태 웹 계층
- 어느 서버든 공유 저장소를 통해 정보를 가져오게 되는 것. (A에만 특정 정보가 존재하지 않음!)
- 공유저장소는 RDB/ 캐시 시스템(Redis) / NoSQL일 수도 있음.

## 데이터 센터

- 지리적 라우팅(geoDNS-routing or geo-routing)에 따라 가까운 데이터 센터로 안내됨.
- 만약 장애가 발생한다면 모든 트래픽은 장애가 없는 데이터 센터로 전송.

> 기술적 난제

- 트래픽 우회 : 올바른 데이터 센터로 트래픽을 보내기 by GeoDNS
- 데이터 동기화 : 센터마다 별도의 DB가 있다면 트래픽이 우회 되었을 때 정보가 없을 수 있음. 데이터를 여러 센터에 걸쳐 다중화하여 해결.
- 테스트와 배포 : 여러 위치에서 테스트하는 것이 중요.

## 메세지 큐

무손실을 보장하는 비동기 통신을 지원하는 컴포넌트. \*무손실-소비자가 꺼낼 때까지 보관된 메세지는 안전히 보관된다.

- 발행자라 불리는 입력 서비스가 메세지를 만들어 메시지 큐에 발행.
- 소비자or구독자라 불리는 서버에 큐가 연결되어 메세지를 받아 그에 맞는 동작 수행.
- 오래걸리는 작업(ex.사진 보정)을 비동기로 처리하여 작업을 완료함.

메세지 큐는 각 컴포넌트가 보다 느슨히 결합 되도록 하고 결함에 대한 내성을 높임.

## 로그, 메트릭, 자동화

> 로그

- 에러 로그 모니터링
- 시스템의 오류 문제 파악

> 메트릭

- 시스템의 현재 상태 파악. 시간에 따른 추이를 추적할 가치가 있는 데이터
- 호스트 단위 메트릭: CPU, MEM ,DISK I/O에 대한 메트릭
- 종합 메트릭: DB계층의 성능, 캐시 계층의 성능 등
- 핵심 비즈니스 메트릭 : 일별 능동 사용자, 수익, 재방문 같은 것

> 자동화

- 빌드, 테스트, 배포 등의 절차 자동화 / CI도와주는 도구 활용

## DB 규모 확장

> 수직적 확장

이전의 스케일업. H/W 성능을 높이자!

- H/W한계로 무한 증설은 어렵다. 결국 한대의 서버로는 감당하기 어렵다
- SPOF로 인한 위험이 크다. 동작을 안하면 시스템 전체가 중단.
- 비용이 많이 든다.

> 수평적 확장

샤딩(Sharding)이라 부르기도 함. 서버 개수를 증가!

- 샤딩이란 작은 단위로 분할하는 것. 모든 샤드는 같은 스키마를 쓰지만 데이터의 중복은 없다 by Hashing
- 샤딩 키를 어떻게 정하는지가 중요.

- 데이터의 재 샤딩 :
  - 데이터가 너무 많아져 하나의 샤드로는 더이상 감당하기 어려울 때
  - 샤드 간 데이터 분포가 균등하지 못할 때
  - 해시 같은 함수를 변경하여야 함.
- 유명인사 문제 : AKA 핫스팟 키
  - 특정 샤드에 질의가 집중되어 서버 과부하
  - 유명인사별로 샤드를 하나씩 할당 or 더 잘게 쪼개기
- 조인과 비정규화
  - 많이 쪼개면 조인하기 힘들다..
  - DB를 비정규화 하여 하나의 테이블에서 질의가 수행되도록 한다.

## 사용자가 백만 이상이라면,,,

시스템을 계속 가다듬으며 최적화, 더 잘개 쪼개기가 필요.
이러한 규모 확장을 위해서는,..

- 웹 계층은 Stateless!
- 모든 계층은 다중화
- 가능한 많은 데이터 캐싱
- 데이터 센터는 여러개
- 정적 콘텐츠는 CDN
- 데이터 계층은 샤딩을 통한 규모 확장
- 각 계층은 독립적 서비스
- 지속 모니터링, 자동화 도구 활용..!
