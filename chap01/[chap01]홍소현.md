# Ch1. 사용자 수에 따른 규모 확장성

- **단일 서버 시스템**
    
    : 웹, 앱, 데이터베이스, 캐시 등이 전부 서버 한 대에서 실행
    
    **System Flow**
    
    1. 사용자가 도메인 이름으로 웹사이트에 접속
        
        ← 이를 위해 DNS에 질의
        
    2. DNS 조회 결과로 IP주소 반환
    3. 해당 IP주소로 HTTP 요청이 전달
    4. 요청을 받은 웹 서버가 HTML, JSON 등의 형태로 응답 반환

- 사용자가 증가 → 여러 서버를 두어야 함
    
    웹/모바일 트래픽 처리용(웹 계층), 데이터베이스용 (데이터 계층) 등으로.
    
    이를 분리하면 각각을 독립적으로 확장 가능
    
- **관계형 데이터베이스** (MySQL, Oracle, PostgreSQL)
    
    : 자료를 테이블, 열, 칼럼으로 표현. SQL로 여러 테이블 조인 가능
    

- **비 관계형 데이터베이스** (CouchDB, Neo4j, HBase, DynamoDB)
    
    : 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소로 나누어짐. 일반적으로 조인 연산 지원X
    

**** 비 관계형 데이터베이스가 바람직한 경우**

- 다루는 데이터가 비정형임
- 아주 많은 양의 데이터 저장이 필요
- 데이터를 직렬화(serialize) or 역직렬화 할 수만 있으면 됨
- 아주 낮은 응답지연시간 요구

- **수직적 규모 확장 (Scale Up)**
    
    : 서버에 고사양 자원(CPU, RAM)을 추가하는 것
    
    유입되는 트래픽 양이 적은 경우 적절하고, 단순하다는 장점
    
    하지만 확장에 한계가 있고, 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안 제시X
    
- **수평적 규모 확장 (Scale Out)**
    
    : 더 많은 서버를 추가하여 성능을 개선하는 것
    
    대규모 애플리케이션 지원에 적절
    
- **로드 밸런서**
    
    : 부하분산 집합(load balancing set)에 속하는 웹 서버에 트래픽 부하를 고르게 분산시키는 역할
    
    로드 밸런서를 도입→ 클라이언트는 로드 밸런서 Public IP로 접속
    
    보안을 위해 로드 밸런서는 웹 서버와 통신을 위해 Private IP를 이용
    
    → 웹 서버가 클라이언트를 직접 처리하지 않도록 함
    
    ⇒  장애 자동복구(failover)문제 해결, 웹 계층 가용성(availability) 향상
    
- **데이터베이스 다중화**
    
    : 서버 사이에 주(master)—부(slave) 관계를 설정, 데이터 원본을 주 서버에, 사본을 부 서버에 저장하는 방법
    
    쓰기 연산은 master에서만 지원, 읽기 연산은 slave에서 지원
    
    ⇒ 데이터베이스 변경 명령(insert, delete, update)은 주 DB 서버에만 전달되어야 함
    
    대부분의 애플리케이션은 읽기 연산의 비중이 훨씬 크므로, 통상 부 DB서버가 주 DB서버보다 많음
    
    - 장점
        - 데이터 변경 연산은 주 서버에, 읽기 연산은 부 서버로 분산되어, 병렬로 처리될 수 있는 query의 수가 증가 → 성능 향상
        - 데이터베이스 서버 중 일부가 파괴되어도 데이터는 보존됨 → 안전성(reliability) 향상
        - 하나의 데이터베이스 서버에 장애가 발생해도 다른 서버의 데이터를 가져와 지속적인 서비스 가능 → 가용성(availability) 향상
    

- **캐시**
    
    : 값비싼 연산 결과 or 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리되도록 하는 저장소
    
    - **캐시 계층 (Cache Tier)**
        
        : 데이터가 잠시 보관되는 곳. 데이터베이스보다 훨씬 빠름
        
        별도의 캐시 계층을 두면 → 성능 개선, 데이터베이스 부하 감소, 독립적인 캐시 계층 규모 확장이 가능
        
    - **읽기 주도형 캐시 전략 (read-through caching strategy)**
        
        : 요청을 받으면 캐시에 응답이 저장되어있는지 확인 후, 있으면 바로 클라이언트로 반환, 없으면 데이터베이스에 질의하는 방법
        
        + 이 외에도 데이터의 종류, 크기, 액세스 패턴에 맞는 다양한 캐시 전략 존재
        
    
    - **캐시 사용 시 유의점**
        - 영속적으로 보관할 데이터는 캐시가 아닌 지속적 저장소(persistent data store)에 두어야 함
        - 캐시에 보관된 데이터의 만료 정책을 마련해두어야 함
        - 저장소의 원본 갱신 연산 — 캐시 갱신 연산을 단일 트랜잭션으로 처리해야 함 (일관성 유지를 위함)
        - 단일 장애 지점(Single Point of Failure, SPOF) 방지를 위해 여러 지역에 걸쳐 캐시 서버를 분산해야 함
        - 캐시 크기가 작아 데이터가 밀려나는 eviction 방지를 위한 방법은 캐시 메모리 과할당(overprovision) 뿐임
            - **데이터 방출(ecivtion) 정책**
                - LRU(Least Recently Used) : 가장 오래전에 사용된 데이터를 방출
                - LFU(Least Frequently Used) : 가장 사용 빈도가 낮은 데이터를 방출
                - FIFO(First In First Out) : 가장 먼저 캐시에 들어온 데이터를 방출
    
- **콘텐츠 전송 네트워크 (CDN)**
    
    : 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크. 이미지, 비디오, CSS, Javascript 파일 등 캐시 가능
    
    - 동작 방식
        
        사용자 웹 사이트 방문 → 해당 사용자에게 가장 가까운 CDN서버가 정적 콘텐츠를 전달 (가장 빠르게 전달이 가능하기 때문)
        
    
    - **CDN 사용 시 고려해야 할 점**
        - 비용 : third-party provider에 의해 운영됨 → 자주 사용되지 않는 콘텐츠를 캐싱하는 것은 비용적으로 좋지 않음
        - 적절한 만료 시한 설정 : time-sensitive한 콘텐츠는 만료 시점을 잘 정해야 함
        - CDN 장애에 대한 대처방안 : CDN 자체가 죽는 경우, 웹/앱이 어떻게 동작해야 하는지 고려 + CDN이 응답하지 않는 경우 문제 감지 후, 원본 서버로부터 직접 콘텐츠를 가져오도록 구성
        - 콘텐츠 무효화(invalidation) 방법 : 아직 만료되지 않은 콘텐츠도 CDN에서 제거

- **Stateless 웹 계층**
    
    : 웹 계층 수평적 확장을 위해, 상태 정보(세션 등)를 웹 계층에서 제거하고, 상태 정보는 관계형DB나 NoSQL 같은 지속성 저장소에 보관하여 필요할 때 가져오도록 구성하는 방법
    
    같은 클라이언트의 요청은 항상 같은 서버로 전송 
    
    → 대부분의 로드밸런서가 이를 지원하기 위해 고정 세션(sticky session) 기능을 제공하나, 이는 로드 밸런서에 부담
    

- **데이터 센터**
    - 장애가 없는 상황, 사용자는 가장 가까운 데이터 센터로 안내됨 (지리적 라우팅, geoDNS-routing or geo-routing)
        
        지리적 라우팅에서의 geoDNS = 사용자 위치에 따라 도메인 이름을 어떤 IP주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스
        
    - 데이터 센터 중 하나에 심각한 장애 발생 시, 모든 트래픽이 장애 없는 데이터 센터로 전송됨
    - 
    - **다중 데이터센터 아키텍처를 만들기 위해 해결해야 할 기술적 난제**
        - 트래픽 우회 : 올바른 데이터 센터로 트래픽을 보낼 효과적인 방법 찾아야 함
        - 데이터 동기화(synchronization) : 데이터센터마다 별도의 DB를 사용한다면, 장애가 자동복구(failover)되어 트래픽이 우회되어도 해당 데이터 센터에는 찾으려는 데이터가 없을 수 있음 → 여러 데이터센터에 걸쳐 데이터를 다중화하여 해결
        - 테스트와 배포(deployment) : 웹/앱을 여러 위치에서 테스트, 자동화된 배포 도구 사용
    
    - 시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있도록 해야 함 (→ 실제 분산 시스템에서 message queue가 핵심 전략 중 하나)
    
- **메시지 큐 (Message Queue)**
    
    : 메시지의 무손실(durability)을 보장하는 비동기 통신(asynchronous communication)을 지원하는 컴포넌트.
    
    - **기본 아키텍처**
        
        생산자 or 발행자(producer/publisher)인 입력 서비스가 메시지를 만들어, message queue에 발행
        
        → 큐에는 보통 소비자 or 구독자 (consumer/subscriber)인 서비스/서버가 연결되어, 메시지를 받아 그에 맞는 동작을 수행
        
    - 서비스/서버 간 결합이 느슨해져, 규모 확장성이 보장되어야 하는 안정적 애플리케이션 구성에 좋음
        
        (생산자는 소비자 프로세스가 다운되어도 메시지 발행 가능 & 소비자는 생산자 서비스가 비가용 상태여도 메시지 수신 가능)
        
        - 사용 예
            
            : 이미지 크로핑(cropping), 샤프닝(sharpening), 블러링(blurring) 등을 지원하는 사진 보정 애플리케이션 : 보정은 시간이 오래 걸릴 수 있는 프로세스이므로, 비동기적으로 처리
            
        
- 로그, 메트릭(metric), 자동화(automation)
    - 로그 : 서버 단위 모니터링 + 로그를 단일 서비스로 모아주는 도구를 활용 가능
    - 메트릭 : 사업 현황에 대한 유용한 정보 습득, 시스템의 현재 상테 쉽게 파악 가능
        - 몇 가지 유용한 메트릭
            - 호스트  단위 메트릭 : CPU, 메모리, 디스크 I/O에 관한 메트릭
            - 종합(aggregated) 메트릭 : 데이터베이스 계층의 성능, 캐시 계층의 성능
            - 핵심 비즈니스 메트릭 : daily active user, 수익(revenue), 재방문(retention)
    - 자동화 : 시스템이 크고 복잡해지는 경우 생산성을 높임. 지속적 통합(continuous integration, CI)을 돕는 도구 활용
        
        
- **데이터베이스의 규모 확장**
    - **수직적 확장 (Scale Up)**
        
        : 기존 서버에 더 많은, or 고성능의 자원 (CPU, RAM, 디스트 등)을 증설하는 방법
        
        데이터베이스 서버 하드웨어에는 한계가 있음. → CPU, RAM 무한 증설 불가, 사용자가 늘어나면 한 대의 서버로 감당 불가
        
        SPOF(single point of failure)로 인한 위험성 큼
        
        비용이 많이 듦
        
    - **수평적 확장 (Sharding)**
        
        : 더 많은 서버를 추가함으로써 성능을 향상시키는 방법
        
        대규모 데이터베이스를 샤드(shard)라는 작은 단위로 분할하는 기술. 모든 샤드는 같은 스키마 사용, 보관되는 데이터는 중복X
        
        - 샤딩 전략 구현
            
            : 샤딩 키(sharding key)/파티션 티(partition key) 선택 고려. 키는 데이터가 어떻게 분산될지를 결정하는 하나 이상의 칼럼이며, 데이터를 고르게 분할할 수 있도록 결정해야 함
            
        - **샤딩 도입 시 문제점**
            - **데이터의 재 샤딩(resharding)**
                
                : 하나의 샤드로 많은 데이터 감당이 힘든 경우, 샤드 간 데이터 분포 균등치 못해 특정 샤드 공간 소모가 빠른 경우 — 샤드 소진(shard exhaustion)현상 발생 
                
                → 샤드 키 계산 함수 변경, 데이터 재배치
                
            - **유명인사(celebrity) 문제**
                
                : 핫스팟 키(hotspot key)문제 라고도 하는, 특정 샤드에 질의가 집중되어 서버 과부하가 걸리는 문제
                
                다수의 유명인사가 하나의 샤드에 저장된 DB의 경우, 소셜 애플리케이션 구축 시 해당 샤드에 read연산으로 인해 과부하 발생
                
            - **조인과 비정규화(join & de-normalization)**
                
                : 여러 샤드 서버로 쪼개고 나면, 다시 조인하기 힘들어짐 → 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 함
                
- **백만 사용자, 그리고 그 이상**
    - 시스템 규모 확장을 위해 살펴본 기법들
        - 웹 계층 = stateless
        - 모든 계층에 다중화 도입 (웹 계층, 데이터 계층)
        - 가능한 한 많은 데이터를 캐시할 것
        - 여러 데이터 센터 지원
        - 정적 콘텐츠는 CDN을 통해 서비스
        - 데이터 계층은 샤딩을 통해 규모 확장
        - 각 계층은 독립적 서비스로 분할
        - 시스템 지속적으로 모니터링, 자동화 도구 활용