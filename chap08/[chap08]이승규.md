# URL 단축기 설계

## 1. 문제 이해 및 설계 범위 확정

- 단축 URL을 제공하고 제공한 URL로 접속하면 원래 URL로 리다이렉트되어야 함.
- 매일 1억 개의 단축 URL을 만들어낼 수 있어야 함.
- URL의 길이는 짧으면 짧을수록 좋음.
- 단축 URL에는 숫자와 영문자 (0\~9, a\~z, A\~Z)만 포함될 수 있음.
- 생성한 단축 URL의 갱신과 제거는 불가능함.

### 개략적 추정

- 쓰기 연산: 매일 1억 개의 단축 URL 생성
- 초당 쓰기 연산: 1억/24/3600 = 1,160
- 읽기 연산: 쓰기 연산과 읽기 연산의 비율을 10:1이라고 하면 읽기 연산은 초당 11,600회 발생
- 10년간 서비스 운영시 1억 * 365 * 10 = 3560억 개의 레코드 보관 필요
- 축약 전 URL의 평균 길이는 100
- 따라서 10년동안 필요한 저장 용량은 3650억 * 100바이트 = 36.5TB

## 2. 개략적 설계안 제시 및 동의 구하기

- API 엔드포인트는 REST 스타일로 설계, 총 2개의 엔드포인트가 필요하다.
  - URL 단축용 엔드포인트: POST 요청으로 단축시킬 URL을 인자로 실어서 보낸다.
- URL 리다이렉션용 엔드포인트: 단축 URL에 대해 HTTP 요청이 오면 원래 URL로 리다이렉트 시켜주기 위한 엔드포인트.
  - 응답 상태코드로 301 또는 302를 사용할 수 있다. 둘의 차이는 다음과 같다.
    - 301 Permanently Moved: 요청한 URL이 Location 헤더에 담긴 URL으로 영구적으로 옮겨졌다는 의미이다. 따라서 브라우저는 요청한 URL에 대해 반환된 웹페이지를 캐싱하게 된다.
    - 302 Found: 요청 URL이 일시적으로 Location 헤더에 담긴 URL으로 옮겨졌음을 의미한다. 따라서 요청이 캐싱되지 않고 언제나 단축 URL 서버로 먼저 요청을 보낸 후 원래 URL으로 리다이렉트된다.
    - 성능적 측면에서는 301 상태코드를 사용하는 것이 유리하나 트래픽 분석에는 302를 사용하는것이 더 유리하다.

### URL 단축

- 단축 URL이 `www.tinyurl.com/{hashValue}`와 같은 형태일 때 중요한 것은 긴 URL을 단축시킬 해시함수이다.
- 이때 사용될 해시함수는 다음 요구사항을 만족해야 한다.
  - 입력값이 달라지면 출력값도 달라져야 한다.
  - 원본의 긴 URL으로 복원될 수 있어야 한다. <- 의아한 부분이다. 왜냐하면 해시함수는 원본 복원이 불가능하기 때문이다
 
## 3. 상세 설계

- 모든 단축 URL 정보를 메모리에 저장하는 것은 실제 시스템에서 사용하기에는 부적절하다. 그러므로 관계형 데이터베이스에 단축 URL 정보를 저장한다.
- 아래 그림과 같이 id, shortURL, longURL을 필드로 가지는 테이블에 저장한다.
<img width="268" alt="스크린샷 2024-07-15 오전 1 48 53" src="https://github.com/user-attachments/assets/1d2ee27d-243a-42ee-bdc5-05c4cb0c4127">

### 해시값 길이 정하기

- 단축 URL에 사용될 수 있는 문자의 총 개수는 10 + 26 + 26 = 62개다.
- 10년간 저장될 총 예상 URL의 개수는 3650억 개였으므로, 가짓수가 3650억개보다 높아지는 최소 길이를 정할 것이다.
- 길이 7이면 3.5조개의 가짓수를 만들 수 있다.

### 해시 함수 구현 기술

**해시 후 충돌 해소**

- 해시값을 만드는 가장 쉬운 방법은 이미 잘 알려진 해시 함수들을 사용하는 것이다. 
<img width="587" alt="스크린샷 2024-07-15 오전 1 55 22" src="https://github.com/user-attachments/assets/14d033c5-c008-44f1-a323-940904eda251">

- 이 함수들의 결과값은 7을 훨씬 넘어선다. 이를 해결하기 위해 결과값의 앞 7자리만 사용하는 방법을 사용할 수 있다.
- 하지만 이 경우 해시값 충돌이 발생할 가능성이 높아진다. 충돌을 해결하기 위해 충돌이 발생하면 원본 longURL에 문자열을 추가한 뒤 다시 해싱하는 작업을 반복한다. 이는 큰 오버헤드를 발생시킬 수 있다.
<img width="833" alt="스크린샷 2024-07-15 오전 1 59 07" src="https://github.com/user-attachments/assets/13a101e5-a7eb-4a16-87cd-80debb028597">

- (그런데 이 전체 과정에 함정이 하나 있다. 해시 함수의 결과 표를 보면 해시 결과가 16진수값이다. 따라서 해시 결과에 사용되는 문자들은 0\~9 + a\~f 로 총 16개이다. 원래 요구사항에 해시함수는 총 62개의 문자로 이뤄져있도록 되어 있다. 따라서 7자리로 만들 수 있는 해시값의 종류가 크게 적어진다. 실제로 $16 ^ 7 \approx$ 2.6억으로 요구사항에 비해 터무니없이 적다. 만약 해시 후 충돌 해소 방식을 위 요구사항에 맞게 사용할거라면 이 부분을 보완할 방식도 추가로 마련해야 한다.)
- 충돌 확인을 위해 매번 데이터베이스 질의를 하는 것은 비효율적이다. 따라서 '블룸 필터' 기술을 사용해 성능 향상을 노릴 수 있다.
- 블룸 필터는 아래와 같이 $m$ 크기의 배열에 $k$개의 해시함수를 사용하여 표시를 해놓는다. 새로운 값 $w$가 이미 집합에 포함되어 있는지 확인하려면 $w$에 대해 각 해시값의 결과 비트가 모두 1로 표시되어있는지 확인하면 된다.
<img width="375" alt="스크린샷 2024-07-15 오전 2 21 17" src="https://github.com/user-attachments/assets/4515625a-18ca-4bb5-8c50-5f20e4a070b4">

- 블룸 필터는 실제로는 집합에 원소가 포함되어있지 않은데 포함되어있다고 반환하는 '긍정 오류'는 발생하지만 그 반대인 '부정 오류'는 절대 발생하지 않는 특성이 있다. 즉, 어떤 URL 아직 저장되어있지 않다고 판단되면 즉시 데이터베이스에 해당 URL을 저장하면 된다. 따라서 API 서버에 블룸 필터를 두고 URL 저장 여부를 먼저 확인한 후, 저장되어있다고 판단할 때만 데이터베이스 질의를 통해 진짜로 저장되어있는지 확인하면 된다.


**base-62 변환**

- 수의 표현 방식이 다른 두 시스템이 같은 수를 공유해야하는 경우에 유용하다.
- 단지 다른 표현방식의 숫자를 62진법으로 변환한 것이다. 해시함수가 아니고 데이터 인코딩 방식이다(해시함수는 고정길이의 출력을 발생시켜야 함).
- longURL을 인풋으로 사용하는 것이 아니라 별도의 ID 생성기를 이용해 ID를 생성한 후 이 ID를 base-62 방식으로 인코딩하여 shortURL을 얻는다.
<img width="641" alt="스크린샷 2024-07-15 오전 2 50 55" src="https://github.com/user-attachments/assets/2f015004-91d2-4096-acd4-a0a3827a52f7">

### URL 리다이렉션 상세설계

- 읽기가 쓰기보다 더 빈번하게 발생하는 시스템이므로 캐시를 두어 성능을 개선한다. 
<img width="822" alt="스크린샷 2024-07-15 오전 3 04 12" src="https://github.com/user-attachments/assets/6aefbc8a-12bc-4765-90bb-24a044dca6dc">

## 4. 마무리

- 요청이 과하게 몰릴 경우 서버가 무력화 될 수 있으므로 처리율 제한 장치를 두는 것을 고려해야 한다.
- 해당 시스템의 웹 요소들은 무상태이다. 따라서 규모 확장에 자유롭다.
- 데이터베이스 다중화 혹은 샤딩을 통해 데이터베이스 규모 확장을 할 수 있다.
- 데이터 분석 솔루션을 적용할 수 있다.
