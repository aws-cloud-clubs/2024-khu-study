# #7 분산 시스템을 위한 유일 ID 생성기 설계

## 1단계 문제 이해 및 설계 범위 특정

- 어떤 특성을 갖는가
- 새로운 레코드에 붙일 ID값은 항상 1보가 큰가?
- ID의 데이터 타입은?
- 시스템 규모는?

## 2단계 개략적 설계안 제시 및 동의 구하기

- 다중 마스터 복제
- UUID
- 티켓 서버
- 트위터 스노플레이크 접근법

> 다중 마스터 복제

DB auto-increment를 활용. k만큼 증가

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움
- ID유일성은 보장되지만 시간 흐름에 맞추어 커지도록 보장할 수 없음
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어려움.

> UUID

컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트 짜리 수. 충돌 가능성은 매우 낮음.

장점

- 만들기 단순
- 서버가 알아서 만드므로 규모 확장도 쉬움

단점

- ID가 128비트로 길다. 이번 장의 요구사항과 맞지 않음
- 시간순 정렬 불가능
- 숫자가 아닌 값이 포함될 수 있음

> 티켓서버

auto_increment가 되는 티켓 서버를 중앙 집중형으로 하나만 사용

장점

- 유일성이 보장되는 숫자로만 ID 생성
- 구현하기 쉬움
- 중소규모 애플리케이션에 적합

단점

- 티켓 서버의 SPOF

> 트위터 스노플레이크 접근법

64비트 구조를 여러 section으로 분할.

- 사인비트 1비트
- 타임스탬프 41비트
- 데이터센터 5비트 / 32개의 센터
- 서버ID 5비트 / 센터당 32개의 서버
- 일련번호 12비트 / 생성시마다 1씩 증가.

## 3단계 상세 설계

데이터 센터와 서버 ID는 시스템 시작시 결정. 운영중에는 바뀌지 않음

> 타임스탬프

시간 흐름에 따라 큰 값을 가지므로 정렬가능. UTC시각도 추출 가능.

> 일련번호

12비트로 4096개 생성가능. 같은 밀리초안에 여러 ID를 만들어야만 0보다 큰 값을 갖음.

## 4단계 마무리

추가로 논의할만한 사항

- 시계 동기화 : 서버마다 다른 시계를 갖으므로 서로 다른 시간을 갖고 있을 수 있음. NTP(Network Time Protocol)이 보편적인 해결책

- 각 섹션 길이 최적화: 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호의 길이를 줄이고 타임스탬프의 길이를 늘리는 것이 효과적일 수도,,,

- 고가용성: ID생성기는 항상 필요하므로 매우 높은 고가용성을 제공해야 함.
