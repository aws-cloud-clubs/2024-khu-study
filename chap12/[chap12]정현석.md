# #12 채팅 시스템 설계
- 채팅 앱이라고 했을 때 사람들이 떠올리는 것은 제각각이므로, 요구사항을 확실하게 해 두는 것이 중요

## Step1. 문제 이해 및 설계 범위 확정

- 응답지연이 낮은 1:1 채팅 기능
- 최대 100명까지 참여할 수 있는 그룹 채팅 기능
- 사용자의 접속상태 표시 기능
- 다양한 단말 지원
    - 하나의 계정으로 여러 단말에 동시 접속 지원
- 푸시 알림
- 5천만 DAU를 처리할 수 있도록 설계


## Step2. 개략적 설계안 제시 및 동의 구하기

- 클라이언트와 서버의 통신 방법에 대한 기본적 지식을 갖추어야 함

채팅 시스템의 경우 클라이언트는 모바일 앱이거나 웹 애플리케이션이다. 클라이언트는 서로 직접 통신하지 않는다. 대신, 각 클라이언트는 위에 나열한 모든 기능을 지원하는 채팅 서비스와 통신한다.

이 채팅 서비스는 다음과 같은 기능을 제공해야 한다.

- 클라이언트들로부터 메세지 수신
- 메세지 수신자(recipient) 결정 및 전달
- 수신자가 접속(online) 상태가 아닌 경우에는 접속할 때까지 해당 메세지 보관

### 폴링

- 클라이언트가 주기적으로 서버에게 새 메세지가 있냐고 물어보는 방법

![폴링](https://github.com/user-attachments/assets/dd97062c-2097-4282-8e98-1a237e65fca7)

폴링 비용은 폴링을 자주하면 할수록 올라간다. 답해줄 메세지가 없는 경우에는 서버 자원이 불필요하게 낭비된다는 문제도 있다.

### 롱 폴링

- 폴링이 여러 가지로 비효율적일 수 있어서 나온 기법

![롱폴링](https://github.com/user-attachments/assets/42106fd5-47a0-46be-86ec-f617f234cf19)

클라이언트는 새 메세지가 반환되거나 타임아웃 될 때까지 연결을 유지한다. 클라이언트는 새 메세지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.

**약점**

- 메세지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있다. HTTP 서버들은 보통 무상태(stateless) 서버다. 로드밸런싱을 위해 라운드 로빈(round robin) 알고리즘을 사용하는 경우, 메세지를 받은 서버는 해당 메세지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있는 것이다.
- 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 수 있는 방법이 없다.
- 여전히 비효율적이다. 메세지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속해야 한다.

### 웹소켓

- 서버가 클라이언트에게 비동기(async) 메세지를 보낼 때 가장 널리 사용하는 기술

![websocket](https://github.com/user-attachments/assets/9c1323c4-71e0-4f72-8e33-00f5922d1297)

웹소켓 연결을 클라이언트가 시작한다. 한 번 맺어진 연결을 항구적이며 양방향이다. 이 연결은 처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드된다. 일단 이 항구적인 연결이 만들어지고 나면 서버는 클라이언트에게 비동기적으로 메세지를 전송할 수 있다.  
**웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야 한다는 것은 주의해야 한다.**

![개략적 설계안](https://github.com/user-attachments/assets/5f316122-6432-4c65-9ddd-9ed2ce2e8360)

위의 설계안에서 **실시간으로 메세지를 주고 받기 위해 클라이언트는 채팅 서버와 웹소켓 연결을 끊지 않고 유지한다는 것**을 유의해야 한다.

- 채팅 서버는 클라이언트 사이에 메세지를 중계하는 역할을 담당
- 접속 상태 서버(presence server)는 사용자의 접속 여부를 관리
- API 서버는 로그인, 회원가입, 프로파일 변경 등 그 외 나머지 전부를 처리
- 알림 서버는 푸시 알림을 전송
- 키-값 저장소(key-value store)에는 채팅 이력(chat history)을 보관
    - 시스템에 접속한 사용자는 이전 채팅 이력을 전부 보게됨

**저장소**  
채팅 시스템이 다루는 데이터는 다음과 같이 두 가지이다.

1. 사용자 프로파일, 설정, 친구 목록처럼 일반적인 데이터
2. 채팅 시스템에 고유한 데이터로, 바로 채팅 이력(chat history)

### 데이터 모델
- 1:1 채팅을 위한 메세지 테이블 설계
- 그룹 채팅을 위한 메세지 테이블

**메세지 ID**

- message_id를 만드는 기법은 자세히 논의할 만한 가치가 있는 흥미로운 주제

message_id는 메세지들의 순서도 표현할 수 있어야 한다. 이를 만족하기 위해서는 다음과 같은 속성을 만족해야 할 것이다.

- mesage_id의 값은 고유해야 함(uniqueness)
- ID 값은 정렬 가능해야 하며 시간 순서와 일치해야 함
    - 새로운 ID는 이전 ID보다 큰 값


## Step3. 상세 설계

### 서비스 탐색

- 서비스 탐색 기능의 주된 역할은 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것
    - 이때 사용되는 기준으로는 클라이언트의 위치(geographical location), 서버의 용량(capacity) 등이 존재

서비스 탐색 기능을 구현하는 데 널리 쓰이는 오픈 소스 솔루션으로는 아파치 주키퍼(Apache Zookeeper) 같은 것이 있다.

### 메세지 흐름

- 1:1 채팅 메세지 처리 흐름 설계
- 여러 단말 사이의 메세지 동기화 설계
- 소규모 그룹 채팅에서의 메세지 흐름

### 접속 상태 표시

사용자의 상태가 바뀌는 시나리오는 몇 가지가 존재한다.  
1. 사용자 로그인
2. 로그아웃
3. 접속 장애

## Step4. 마무리

면접 말미에 시간이 좀 남는다면 면접관과 다음과 같은 내용을 논의해도 좋을 것이다.

- 채팅 앱을 확장하여 사진이나 비디오 등의 미디어를 지원하도록 하는 방법
- 종단 간 암호화
- 캐시
- 로딩 속도 개선
- 오류 처리