# Ch6

# 키-값 저장소 설계

### 키-값 저장소(key-value store)

- 비관계형(non-relational) 데이터베이스
- 저장된 값은 고유 식별자(indentifier)를 키로 가져야 함
- 키는 일반적으로 텍스트나 해시 값을 가질 수 있고, 성능상의 이유로 짧을수록 좋음
- 값은 문자열, 리스트, 객체 등 무엇이 오든 상관 없음

- put(key, value) : 키-값 쌍을 저장소에 저장
- get(key) : 인자로 주어진 키에 매달린 값을 꺼냄

### 문제 이해 및 설계 범위 확정

 : 읽기, 쓰기, 메모리 사용량 사이 균형을 찾고,
데이터의 일관성-가용성 사이에 타협적 결정을 내린 설계여야 함

- 키-값 쌍 크기 10KB 이하
- 큰 데이터 저장 가능
- 높은 가용성 제공 - 시스템은 장애가 생기더라도 빨리 응답해야 함
- 높은 규모 확장성 제공 - 트래픽 양에 따라 자동적으로 서버 증설/삭제 되어야 함
- 데이터 일관성 수준 조정 가능
- 짧은 응답 지연시간(latency)

### 단일 서버 키-값 저장소

한 대의 서버만 사용하는 키-값 저장소 설계 중 가장 직관적인 방법

= 키-값 쌍 전부를 해시 테이블로 저장하는 것

→ 이 접근법은 빠른 속도를 보장하나, 모든 데이터를 메모리 안에 두는 것이 불가능할 수 있음

- 개선책
    - 데이터 압축
    - 자주 쓰이는 데이터만 메모리에 두고, 나머지 디스크에 저장

이렇게 개선하더라도, 한 대의 서버로 부족해질 수 있음

많은 데이터 저장을 위해서는 분산 키-값 저장소를 만들어야 함

### 분산 키-값 저장소

: 분산 해시 테이블이라고도 불림. 키-값 쌍을 여러 서버에 분산시킴

- **CAP 정리**
    
    : 데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance) 3가지 요구사항을 동시에 만족하는 분산 시스템 설계는 불가능하다는 정리
    
    - 데이터 일관성
        
        : 분산 시스템 접속 클라이언트는 어떤 노드에 접속했는지에 관계없이 언제나 같은 데이터를 보게 되어야 함
        
    - 가용성
        
        : 분산 시스템 접속 클라이언트는 일부 노드에 장애가 발생해도 항상 응답을 받을 수 있어야 함
        
    - 파티션 감내
        
        : 파티션은 두 노드 사이에 통신 장애가 발생했음을 의미. 네트워크에 파티션이 생기더라도 시스템은 계속 동작해야 함
        
    
    3가지 요구사항 중 어느 두 가지를 만족하냐에 따라 CP, AP, CA 시스템으로 나눌 수 있음
    
- **데이터 파티션**
    
    : 데이터를 작은 파티션들로 분할한 다음, 여러 서버에 저장하는 것
    
    - 데이터를 여러 서버에 고르게 분산할 수 있는가
    - 노드가 추가되거나 삭제될 때, 데이터의 이동을 최소화 할 수 있는가
    
    → 이는 5장 안정 해시(consistent hash)를 통해 문제를 해결하기에 적합함
    
    **안정 해시를 이용한 데이터 파티션의 좋은 점**
    
    - 규모 확장 자동화(automatic-scailing)
        
        : 시스템 부하에 따라 서버가 자동으로 추가/삭제
        
    - 다양성(heterogeneity)
        
        : 각 서버의 용량에 맞게 가상 노드(virtual node) 수를 조정할 수 있음
        

- **데이터 다중화**
    
    : 높은 가용성과 안정성 확보를 위해 데이터를 N개 서버에 비동기적을 다중화(replication)하는 것. 여기서 N은 튜닝 가능한 값
    
- **데이터 일관성**
    
    : 여러 노드에 다중화된 데이터를 정족수 합의(Quorum Consensus) 프로토콜을 사용하여 읽기/쓰기 연산 모두에 일관성을 보장하는 것
    
    - N : 사본 개수
    - W : 쓰기 연산에 대한 정족수
    - R : 읽기 연산에 대한 정족수
    
    응답 지연과 데이터 일관성 사이의 타협점을 찾아 W, R, N의 값을 정한다
    
    - R=1, W=N : 빠른 읽기 연산에 최적화된 시스템
    - W=1, R=N : 빠른 쓰기 연산에 최적화된 시스템
    - W+R > N : 강한 일관성 보장
    - W+R < N : 강한 일관성 보장 X
    
    ---
    
    - **일관성 모델(consistency model)**
        
        : 데이터의 일관성 수준을 결정함
        
        - 강한 일관성 : 모든 읽기 연산은 가장 최근 갱신된 결과를 반환 (클라이언트는 절대 낡은 데이터를 보지 못함)
        - 약한 일관성 : 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있음
        - 결과적 일관성 : 약한 일관성의 한 형태. 갱신 결과가 결국 모든 사본에 반영
    
    - **비 일관성 해소 기법 : 데이터 버저닝**
        - 버저닝(versioning) : 데이터 변경할 때마다 해당 데이터의 새로운 버전을 만드는 것. 각 버전의 데이터는 변경 불가능
        - 벡터 시계 (vector clock) : [서버, 버전]의 순서쌍을 데이터에 매단 것. 선행버전, 후행버전, 버전 간 충돌 판별에 쓰임
    
    - **장애 처리**
        
        : 장애를 어떻게 처리할 것이냐를 다루기 위해, 장애 감지(failure detection) 기법, 장애 해소(failure resolution) 전략
        
    
    - **장애 감지**
        
        : 모든 노드 사이에 멀티캐스팅(multicasting) 채널 구축 → 두 대 이상의 서버가 한 서버의 장애를 보고해야, 실제 장애 발생으로 간주하는 방법. 서버가 많을 때에는 비효율적
        
        ⇒ 가십 프로토콜(gossip protocol) 같은 분산형 장애 감지 솔루션을 채택하는 것이 보다 효율적.
        
    
    - **일시적 장애 처리**
        - 엄격한 정족수 접근법 - 읽기와 쓰기 연산 금지
        - 느슨한 정속수 접근법 - 정족수 요구사항을 강제하는 대신, 쓰기/읽기 연산을 수행할 W/R 건강한 서버를 해시 링에서 고름
        
    - **영구 장애 처리**
        - 반-엔트로피(anti-entropy) 프로토콜 구현으로 사본들을 동기화
        
    
    ### 요약
    
    분산 키-값 저장소가 가져야 하는 기능, 그 기능 구현에 이용되는 기술
    
    | 목표/문제 | 기술 |
    | --- | --- |
    | 대규모 데이터 저장 | 안정 해시 사용해 서버들에 부하 분산 |
    | 읽기 연산에 대한 높은 가용성 보장 | 데이터를 여러 데이터센터에 다중화 |
    | 쓰기 연산에 대한 높은 가용성 보장 | 버저닝 및 벡터 시계를 사용한 충돌 해소 |
    | 데이터 파티션 | 안정 해시 |
    | 점진적 규모 확장성 | 안정 해시 |
    | 다양성(heterogeneity) | 안정 해시 |
    | 조절 가능한 데이터 일관성 | 정족수 합의 |
    | 일시적 장애 처리 | 느슨한 정족수 프로토콜, 단서 후 임시 위탁 |
    | 영구적 장애 처리 | 머클 트리 |
    | 데이터 센터 장애 대응 | 여러 데이터 센터에 걸친 데이터 다중화 |