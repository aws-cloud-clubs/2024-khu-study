# #6 키-값 저장소 설계
키-값 저장소(key-value store)는 키-값 데이터베이스라고도 불리는 비 관계형(non-relational) 데이터베이스다.
이 저장소에 저장되는 값은 고유 식별자(identifier)를 키로 가져야 한다.
키와 값 사이에 이런 연결 관계를 “키-값” 쌍(pair)라고 지칭한다. 키-값 쌍에서의 키는 유일해야 하며 해당 키에 매달린 값은 키를 통해서만 접근할 수 있다.

- put(key, value): 키-값 쌍을 저장소에 저장
- get(key): 인자로 주어진 키에 매달린 값을 꺼냄

## 단일 서버 키-값 저장소

한 대 서버만 사용하는 키-값 저장소를 설계하는 가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시 테이블로 저장하는 것이다.

이 접근법은 빠른 속도를 보장하지만 모든 데이터를 메모리 안에 두는 것이 불가능할 수도 있다는 약점을 가진다.

이 문제를 해결하기 위한 개선책으로는 다음과 같은 방법들이 있다.

- 데이터 압축(compression)
- 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장

하지만 많은 데이터를 저장하려면 한 대 서버로 부족한 때가 온다.
분산 키-값 저장소(distributed key-value store)를 만들어야할 필요가 있다.

## 분산 키-값 저장소

키-값 쌍을 여러 서버에 분산시키는 탓에 분산 해시 테이블이라고도 불린다.
분산 시스템을 설계할 때는 CAP 정리(Consistency, Availability, Partition Tolerance theorem)를 이해하고 있어야 한다.

### CAP 정리

**데이터 일관성**(consistency), **가용성**(availability), **파티션 감내**(partition tolerance)라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리다.

**각 요구사항들의 의미**

- 데이터 일관성
    - 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 봐야함
- 가용성
    - 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 함
- 파티션 감내
    - 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 것을 의미

> 💡 **파티션 -** 두 노드 사이에 통신 장애가 발생하였음을 의미


CAP 정리는 **이들 가운데 어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다는 것**을 의미한다.

![CAP 정리](https://github.com/user-attachments/assets/4f92f4af-9253-4910-a430-5a354ae7b2d0)

- CP 시스템
    - 일관성과 파티션 감내를 지원하는 키-값 저장소
    - 가용성을 희생
- AP 시스템
    - 가용성과 파티션 감내를 지원하는 키-값 저장소
    - 데이터 일관성을 희생
- CA 시스템
    - 일관성과 가용성을 지원하는 키-값 저장소
    - 파티션 감내는 지원하지 않음
        - 통상 네트워크 장애는 피할 수 없는 일로 여겨짐
        - **분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계**해야 함
        - 따라서 **실제로 CA 시스템은 존재하지 않음**


### 키-값 저장소 구현에 사용될 핵심 컴포넌트 및 기술들
1. 데이터 파티션
2. 데이터 다중화(replication)
3. 일관성(consistency)
4. 일관성 불일치 해소(inconsistency resolution)
5. 장애 처리
6. 시스템 아키텍처 다이어그램
7. 쓰기 경로(write path)
8. 읽기 경로(read path)  
---

1. **데이터 파티션**

대규모 애플리케이션의 경우 전체 데이터를 한 대의 서버로 관리하는 것은 불가능하다.

가장 단순한 해결책은 데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것이다.

**데이터를 파티션 단위로 나눌 때 고민해야할 문제**

- 데이터를 여러 서버에 고르게 분산할 수 있는가
- 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가


2. **데이터 다중화**

높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다. 여기서 N은 튜닝 가능한 값이다.

**N개 서버를 선정하는 방법**

- 어떤 키를 해시 링 위에 배치
- 해당 지점으로부터 시계 방향으로 링을 순회
- 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관

3. **데이터 일관성**

여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.

정족수 합의(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.

4. **일관성 모델**(consistency model)

키-값 저장소를 설계할 때 고려해야 할 또 하나의 중요한 요소이며, 데이터 일관성의 수준을 결정하는데 종류가 다양하다.

- 강한 일관성(strong consistency)
    - 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환
    - 클라이언트는 절대로 낡은(out-of-date) 데이터를 보지 못함
- 약한 일관성(weak consistency)
    - 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있음
- 결과적 일관성(eventual consistency)
    - 약한 일관성의 한 형태
    - 갱신 결과가 결국에는 모든 사본에 반영(즉, 동기화)되는 모델

5. **장애 처리**

대다수 규모 시스템에서 장애는 불가피하기만 한 것이 아니라 아주 흔하게 벌어지는 사건이다. 장애를 어떻게 처리할 것이냐 하는 것은 굉장히 중요한 문제다.

**장애 감지**(failure detection)

분산 시스템에서 보통 두 대 이상의 서버가 똑같이 서버 N의 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주한다.

6. **시스템 아키텍처 다이어그램**

![아키텍처 다이어그램 예시](https://github.com/user-attachments/assets/54e9f800-1d6d-4ad6-9bac-0e70a0c43d55)

**이 아키텍처의 주된 기능들**

- 클라이언트는 키-값 저장소가 제공하는 두 가지 단순한 API, 즉 get(key) 및 put(key, value)와 통신
- 중재자(coordinator)는 클라이언트에게 키-값 저장소에 대한 프락시(proxy) 역할을 하는 노드
- 노드는 안정 해시(consistent hash)의 해시 링(hash ring) 위에 분포
- 노드를 자동으로 추가 또는 삭제할 수 있도록, 시스템은 완전히 분산됨(decentralized)
- 데이터는 여러 노드에 다중화됨
- 모든 노드가 같은 책임을 지므로, SPOF(Single Point of Failure)는 존재하지 않음

7. **쓰기 경로**

![쓰기 경로 사례](https://github.com/user-attachments/assets/3b108366-4942-4a7d-973f-36cd3eb38a82)

① - 쓰기 요청이 커밋 로그(commit log) 파일에 기록된다.

② - 데이터가 메모리 캐시에 기록된다.

③ - 메모리 캐시가 가득차거나 사전에 정의된 어떤 임계치에 도달하면 데이터는 디스크에 있는 SSTable에 기록된다.

> 💡 **SSTable**(Sorted-String Table) - <키, 값>의 순서쌍을 정렬된 리스트 형태로 관리하는 테이블


8. **읽기 경로**

읽기 요청을 받은 노드는 데이터가 메모리 캐시에 있는지부터 살핀다.

![데이터가 메모리에 없을 때 읽기 연산 예시](https://github.com/user-attachments/assets/41ac512f-8fb7-4db7-96d6-52a612b5e417)

① - 데이터가 메모리에 있는지 검사한다. 없으면 ②로 간다.

② - 데이터가 메모리에 없으므로 볼룸 필터를 검사한다.

③ - 볼룸 필터를 통해 어떤 SSTable에 키가 보관되어 있는지 알아낸다.

④ - SSTable에서 데이터를 가져온다.

⑤ - 해당 데이터를 클라이언트에게 반환한다.